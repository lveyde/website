---
title:  The server powering practicalgobook.net
date: 2022-07-27
categories:
-  articles
draft: true
---
I write my blog posts in Markdown format,  and then use the excellent [Hugo](https://gohugo.io/) static site 
generator to generate HTML files. The topic of this blog post is how those HTML files are served
to you.

## Background

When you type in https://practicalgobook.net in your browser (or click it from somewhere), a translation,
commonly known as DNS resolution happens. As a result of this translation, the browser gets back
an IP address:

```
# Ran this command on a Linux system
$ dig +short practicalgobook.net # this is a command to perform DNS resolution
172.105.175.12
```

This IP address refers to a virtual machine running in the cloud. As of a few months back, I am running this
virtual machine on a cloud provider. When the browser's request reaches this virtual machine, 
a **program** then sends back the HTML files that were generated by Hugo. This program is 
written using the Go programming language. I use the standard libraries and two third party packages 
for implementing advanced features. 

Let's dive in!

## Content delivery - Proof of Concept

The first working iteration of the server looked as follows:

```go
package main

import (
	"embed"
	"log"
	"net/http"
	"os"
)

//go:embed posts code
//go:embed index.html index.xml sitemap.xml
//go:embed categories css images
var siteData embed.FS

func main() {
	listenAddr := ":80"
	if len(os.Getenv("LISTEN_ADDR")) != 0 {
		listenAddr = os.Getenv("LISTEN_ADDR")

	}
	mux := http.NewServeMux()
	staticFileServer := http.FileServer(http.FS(siteData))
	mux.Handle("/", staticFileServer)

	log.Fatal(http.ListenAndServe(listenAddr, mux))
}
```

The key standrad libraries used in this iteration were [embed](https://pkg.go.dev/embed) and [net/http](https://pkg.go.dev/net/http).

The `embed` package allowed me build an executable Go application containing all the blog content. As you can see in the `//go:embed`
directives, I include all the directories that `hugo` generated in the default, `public` directory inside the application as
a variable `siteData` of [embed.FS](https://pkg.go.dev/embed#FS) type.

Once this was done, I use the [http.FileServer](https://pkg.go.dev/net/http#FileServer) handler to serve the files that were embedded
and available to the application via the `siteData` variable.

`http.FileServer` expects an argument of a type which implements the [http.FileSystem](https://pkg.go.dev/net/http#FileSystem) interface.

`siteData` which is of type `embed.FS` implements the [fs.FS](https://pkg.go.dev/io/fs#FS) interface and hence, we use the [http.FS](https://pkg.go.dev/net/http#FS) function to convert `siteData` to a value of type `http.FileSystem` and thus, we have the following code snippet above:

```go
mux := http.NewServeMux()
staticFileServer := http.FileServer(http.FS(siteData))
mux.Handle("/", staticFileServer)
```

Then, we call the `ListenAndServe()` function to start the HTTP server on the address specified in `listenAddr`.

To summarize, at this stage, I had:

- I a Go server containing all my blog's files. All I had to do is build my application and copy it to the host using `scp`. I didn't need to copy the contents separately! My blog was *just* an executable.
- It ran on address specified, `:8080` which I specified via `LISTEN_ADDR` environment variable
- I used a cloud provider's load balancer to give me free HTTPS, which means, I had https://practicalgobook.net website working (Traffic flow: Browser -> Load balancer -> Go server (running on port 8080)

Next, I set out to implement support for making the website acessible over HTTPS and without paying for the very expensive load balancer.

## Content Delivery - Caddy as a reverse proxy

During this stage, I made a couple of changes:

- I stopped using the cloud provider's load balancer as it was proving too expensive
- I pointed the DNS record of practicalgobook.net to a self-managed virtual machine

Hence, I would need a way to manage the TLS certificates on the virtual machine myself.

I knew that I am going to use https://letsencrypt.org/ for TLS certificates. I considered managing TLS certificates in the Go server itself using one of the options listed [here](https://letsencrypt.org/docs/client-options/#clients-go). However, quickly realizing it may not be a battle for the day, 
I gave Caddy a go.

I installed [Caddy](https://caddyserver.com/docs/install#fedora-redhat-centos) on my CentOS VM, and wrote the following `Caddyfile`:

```
practicalgobook.net {
    reverse_proxy localhost:8080
        handle_errors {
	     respond "I will be back soon!"
        }
}
```
And that's it! I started `caddy` using the systemd service, started my Go application using a systemd service and I had HTTPS working again without
the expense of running a cloud managed load balancer.

To summarize, at this stage, I had:

- I a Go server containing all my blog's files. All I had to do is build my application and copy it to the host using `scp`. I didn't need to copy the contents separately! My blog was *just* an executable.
- It ran on address specified, `:8080` which I specified via `LISTEN_ADDR` environment variable
- I used Caddy which ran on port 443 and port 80 to give me free HTTPS and forwarded traffic to the Go server on port 8080. I had https://practicalgobook.net website working (Traffic flow: Browser -> Virtual Machine -> Caddy (443) -> Go server (running on port 8080)

I was happy with the progress at this stage, but then I found an issue.

When I wanted to update my blog, I had to stop and start my application which meant there was downtime! And considering that this is a very important
website, I couldn't have that. 

So I set out to fix that.

## Zero-downtime update



## Summary
