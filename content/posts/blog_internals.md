---
title:  The server powering practicalgobook.net
date: 2022-07-27
categories:
-  articles
draft: true
---
I write my blog posts in Markdown format,  and then use the excellent [Hugo](https://gohugo.io/) static site 
generator to generate HTML files. The topic of this blog post is how those HTML files are served
to you.

## Background

When you type in https://practicalgobook.net in your browser (or click it from somewhere), a translation,
commonly known as DNS resolution happens. As a result of this translation, the browser gets back
an IP address:

```
# Ran this command on a Linux system
$ dig +short practicalgobook.net # this is a command to perform DNS resolution
172.105.175.12
```
This IP address refers to a virtual machine running in the cloud. I am running this
virtual machine on a cloud provider. When the browser's request reaches this virtual machine, 
a **program** then sends back the HTML files that were generated by Hugo. This program is 
written using the Go programming language. I use the standard libraries and two third party packages 
for implementing advanced features. 

Let's dive in!

## Content delivery - Proof of Concept

The first working iteration of the server looked as follows:

```go
package main

import (
	"embed"
	"log"
	"net/http"
	"os"
)

//go:embed posts code
//go:embed index.html index.xml sitemap.xml
//go:embed categories css images
var siteData embed.FS

func main() {
	listenAddr := ":80"
	if len(os.Getenv("LISTEN_ADDR")) != 0 {
		listenAddr = os.Getenv("LISTEN_ADDR")

	}
	mux := http.NewServeMux()
	staticFileServer := http.FileServer(http.FS(siteData))
	mux.Handle("/", staticFileServer)

	log.Fatal(http.ListenAndServe(listenAddr, mux))
}
```

The key standrad libraries used in this iteration were [embed](https://pkg.go.dev/embed) and [net/http](https://pkg.go.dev/net/http).

The `embed` package allowed me build an executable Go application containing all the blog content. As you can see in the `//go:embed`
directives, I include all the directories that `hugo` generated in the default, `public` directory inside the application as
a variable `siteData` of [embed.FS](https://pkg.go.dev/embed#FS) type.

Once this was done, I use the [http.FileServer](https://pkg.go.dev/net/http#FileServer) handler to serve the files that were embedded
and available to the application via the `siteData` variable.

`http.FileServer` expects an argument of a type which implements the [http.FileSystem](https://pkg.go.dev/net/http#FileSystem) interface.

`siteData` which is of type `embed.FS` implements the [fs.FS](https://pkg.go.dev/io/fs#FS) interface and hence, we use the [http.FS](https://pkg.go.dev/net/http#FS) function to convert `siteData` to a value of type `http.FileSystem` and thus, we have the following code snippet above:

```go
mux := http.NewServeMux()
staticFileServer := http.FileServer(http.FS(siteData))
mux.Handle("/", staticFileServer)
```

Then, we call the `ListenAndServe()` function to start the HTTP server on the address specified in `listenAddr`.

You can see that the default value of `listenAddr` is port 80 - a privileged port which means I needed super-user permissions to run it.
At this stage, thus I had:

- I a Go server containing all my blog's files. All I had to do is build my application and copy it to the host using `scp`. I didn't need to copy the contents separately! My blog was *just* an executable.
- It ran on port 80, which means, I had http://practicalgobook.net website working (note the HTTP)


## Content Delivery - HTTPS and Reverse proxy


## Zero-downtime update

## Summary
